//--------------------------------------------------------------------------------------
// File: Ambient.fx

// Равномерное освещение(ambient lighting) обеспечивает постоянное начальное 
// освещение для всей сцены. Оно освещает все вершины объектов одинаково, потому что 
// не зависит ни от каких других факторов освещения. Это самый простой и быстрый тип 
// освещения, но при этом дает наименее реалистичный результат. Формула для вычисления 
// этой модели освещения так же очень проста, т.к.там всего одна арифметическая операция 
// — умножение. Для ее вычисления достаточно перемножить цвет материала на интенсивность 
// освещения.
//
// Еременко Денис: dryerem19, равномерное освещение с текстурой
// 08.10.2022
//
//---------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------
// Глобальные переменные
//--------------------------------------------------------------------------------------
texture gDiffuseTexture;        // Рассеянная текстура 
float4  gMaterialAmbientColor;  // Рассеянный цвет материала
float   gAmbientIntensity;      // Интенсивность рассеянного света в пределах [0...1]

float4x4 gWorld;                // Мировая матрица для объекта
float4x4 gWorldViewProjection;  // World * View * Projection matrix

//--------------------------------------------------------------------------------------
// Сэмплеры текстур
//--------------------------------------------------------------------------------------
sampler TextureSampler = sampler_state
{
    Texture = <gDiffuseTexture>;
    MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
};

//--------------------------------------------------------------------------------------
// Входная структура вершинного шейдера
//--------------------------------------------------------------------------------------
struct VS_INPUT
{
	float4 position : POSITION0;  // Позиция вершины
    float3 normal   : NORMAL0;    // Нормаль вершины
    float2 uv       : TEXCOORD0;  // UV координаты вершины
};

//--------------------------------------------------------------------------------------
// Выходная структура вершинного шейдера
//--------------------------------------------------------------------------------------
struct VS_OUTPUT
{
    float4 position : POSITION0; // Позиция вершины
    float4 diffuse  : COLOR0;    // Цвет вершины
    float2 uv       : TEXCOORD0; // UV координаты вершины
};

//--------------------------------------------------------------------------------------
// Этот шейдер вычисляет стандартное преобразование и рассеянное освещение (ambient)
//--------------------------------------------------------------------------------------
VS_OUTPUT mainVS(VS_INPUT input)
{
    VS_OUTPUT output = (VS_OUTPUT) 0;                            // Обнуляем все члены экземпляра выходной структуры
	
    output.position = mul(input.position, gWorldViewProjection); // Преобразуем положение вершины в однородное пространство проекции
    output.diffuse = gMaterialAmbientColor * gAmbientIntensity;  // Установим цвет вершины из формулы AI * AC
    output.uv = input.uv;                                        // Установим текстурные координаты

    return output;                                               // Возвратим результат
}

//--------------------------------------------------------------------------------------
// Выходная структура пиксельного шейдера
//--------------------------------------------------------------------------------------
struct PS_OUTPUT
{
    float4 RGBColor : COLOR0; // Цвет пикселя   
};

//--------------------------------------------------------------------------------------
// Этот шейдер выводит цвет пикселя путём модуляции цвета текстуры 
// с помощью диффузного цвета материала
//--------------------------------------------------------------------------------------
PS_OUTPUT mainPS(VS_OUTPUT input)
{
    PS_OUTPUT output = (PS_OUTPUT)0;                                   // Обнуляем все члены экземпляра выходной структуры
	
    output.RGBColor = tex2D(TextureSampler, input.uv) * input.diffuse; // Модуляция цвета текстуры
	
    return output;                                                     // Возвратим результат
}

//--------------------------------------------------------------------------------------
// Техники отрисовки сцены
//--------------------------------------------------------------------------------------
technique RenderScene
{
	pass P0
	{
        VertexShader = compile vs_2_0 mainVS();
        PixelShader = compile ps_2_0 mainPS();
    }
}